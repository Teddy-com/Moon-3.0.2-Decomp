/*
 * Decompiled with CFR 0.152.
 * 
 * Could not load the following classes:
 *  javax.vecmath.Vector2f
 */
package me.moon.module.impl.exploit;

import java.awt.Color;
import javax.vecmath.Vector2f;
import me.moon.event.Handler;
import me.moon.event.impl.game.PacketEvent;
import me.moon.event.impl.game.TickEvent;
import me.moon.event.impl.player.BoundingBoxEvent;
import me.moon.event.impl.player.MotionEvent;
import me.moon.event.impl.player.PushEvent;
import me.moon.event.impl.player.UpdateEvent;
import me.moon.event.impl.render.InsideBlockRenderEvent;
import me.moon.module.Module;
import me.moon.utils.game.MoveUtil;
import me.moon.utils.game.TimerUtil;
import me.moon.utils.value.impl.EnumValue;
import me.moon.utils.value.impl.NumberValue;
import net.minecraft.block.Block;
import net.minecraft.block.BlockAir;
import net.minecraft.block.BlockHopper;
import net.minecraft.block.BlockLiquid;
import net.minecraft.entity.Entity;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.server.S02PacketChat;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.BlockPos;
import net.minecraft.util.MathHelper;
import net.minecraft.util.MovementInput;

public class Phase
extends Module {
    private final EnumValue<Mode> mode = new EnumValue<Mode>("Mode", Mode.WATCHDOG);
    private int moveUnder;
    private final NumberValue<Double> distance = new NumberValue<Double>("Distance", 2.0, 0.0, 10.0, 0.1);
    private final NumberValue<Double> vanillaSpeed = new NumberValue<Double>("Vanilla Speed", 0.5, 0.0, 3.0, 0.1);
    private final NumberValue<Double> verticalSpeed = new NumberValue<Double>("Vertical Speed", 0.5, 0.0, 3.0, 0.1);
    public static boolean phasing;
    private int delay;
    private final TimerUtil timer = new TimerUtil();

    public Phase() {
        super("Phase", Module.Category.EXPLOITS, new Color(25, 255, 255, 255).getRGB());
        this.setDescription("Walk through Blocks!");
    }

    @Handler(value=TickEvent.class)
    public void onTick(TickEvent event) {
        if (this.mc.thePlayer == null) {
            return;
        }
        switch ((Mode)((Object)this.mode.getValue())) {
            case VANILLA: {
                if (this.mc.thePlayer != null && this.moveUnder == 1) {
                    this.mc.thePlayer.sendQueue.getNetworkManager().sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX, this.mc.thePlayer.posY - 2.0, this.mc.thePlayer.posZ, false));
                    this.mc.thePlayer.sendQueue.getNetworkManager().sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, true));
                    this.moveUnder = 0;
                }
                if (this.mc.thePlayer == null || this.moveUnder != 1488) break;
                double mx = -Math.sin(Math.toRadians(this.mc.thePlayer.rotationYaw));
                double mz = Math.cos(Math.toRadians(this.mc.thePlayer.rotationYaw));
                double x = (double)MovementInput.moveForward * mx + (double)MovementInput.moveStrafe * mz;
                double z = (double)MovementInput.moveForward * mz - (double)MovementInput.moveStrafe * mx;
                this.mc.thePlayer.sendQueue.getNetworkManager().sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX + x, this.mc.thePlayer.posY, this.mc.thePlayer.posZ + z, false));
                this.mc.thePlayer.sendQueue.getNetworkManager().sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(Double.NEGATIVE_INFINITY, this.mc.thePlayer.posY, Double.NEGATIVE_INFINITY, true));
                this.moveUnder = 0;
                break;
            }
            case NCP: {
                if (!this.mc.thePlayer.isCollidedHorizontally || !this.mc.gameSettings.keyBindSprint.isKeyDown()) break;
                this.mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX, this.mc.thePlayer.posY - 0.05, this.mc.thePlayer.posZ, true));
                this.mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX, this.mc.thePlayer.posY, this.mc.thePlayer.posZ, true));
                this.mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX, this.mc.thePlayer.posY - 0.05, this.mc.thePlayer.posZ, true));
            }
        }
    }

    @Handler(value=BoundingBoxEvent.class)
    public void onBB(BoundingBoxEvent event) {
        this.setSuffix(((Mode)((Object)this.mode.getValue())).getName());
        switch ((Mode)((Object)this.mode.getValue())) {
            case ARIS: {
                if (event.getBoundingBox() == null || this.mc.theWorld == null || !(event.getBoundingBox().maxY > this.mc.thePlayer.getEntityBoundingBox().minY) || !this.mc.thePlayer.isSneaking()) break;
                event.setBoundingBox(null);
                break;
            }
            case WATCHDOGNEW: 
            case WATCHDOG: {
                if (!this.isInsideBlock()) break;
                event.setBoundingBox(null);
                break;
            }
            case VANILLA: {
                if (this.mc.thePlayer.isCollidedHorizontally && !this.isInsideBlock()) {
                    double mx = -Math.sin(Math.toRadians(this.mc.thePlayer.rotationYaw));
                    double mz = Math.cos(Math.toRadians(this.mc.thePlayer.rotationYaw));
                    double x = (double)MovementInput.moveForward * mx + (double)MovementInput.moveStrafe * mz;
                    double z = (double)MovementInput.moveForward * mz - (double)MovementInput.moveStrafe * mx;
                    event.setBoundingBox(null);
                    this.mc.thePlayer.setPosition(this.mc.thePlayer.posX + x, this.mc.thePlayer.posY, this.mc.thePlayer.posZ + z);
                    this.moveUnder = 69;
                    break;
                }
                if (!this.isInsideBlock()) break;
                event.setBoundingBox(null);
                break;
            }
            case NCP: {
                if (this.isInBlock(this.mc.thePlayer, 0.0f) && !this.mc.gameSettings.keyBindSprint.isKeyDown() && (double)event.getBlockPos().getY() > this.mc.thePlayer.getEntityBoundingBox().minY - 0.4 && (double)event.getBlockPos().getY() < this.mc.thePlayer.getEntityBoundingBox().maxY + 1.0) {
                    this.mc.thePlayer.jumpMovementFactor = 0.0f;
                    event.setBoundingBox(null);
                }
                if (!this.isInBlock(this.mc.thePlayer, 0.0f) || !this.mc.gameSettings.keyBindSprint.isKeyDown()) break;
                event.setBoundingBox(null);
            }
        }
    }

    @Handler(value=PacketEvent.class)
    public void onPacket(PacketEvent event) {
        S02PacketChat packet;
        if (!event.isSending() && event.getPacket() instanceof S02PacketChat && (packet = (S02PacketChat)event.getPacket()).getChatComponent().getUnformattedText().contains("You cannot go past the border.")) {
            event.setCancelled(true);
        }
        switch ((Mode)((Object)this.mode.getValue())) {
            case VANILLA: {
                if (!event.isSending() && event.getPacket() instanceof S08PacketPlayerPosLook && this.moveUnder == 2) {
                    this.moveUnder = 1;
                }
                if (event.isSending() || !(event.getPacket() instanceof S08PacketPlayerPosLook) || this.moveUnder != 69) break;
                this.moveUnder = 1488;
                break;
            }
            case NCP: {
                if (!event.isSending() || !(event.getPacket() instanceof C03PacketPlayer) || this.mc.thePlayer.isMoving() || this.mc.thePlayer.posY != this.mc.thePlayer.lastTickPosY) break;
                event.setCancelled(true);
            }
        }
    }

    @Handler(value=MotionEvent.class)
    public void onMove(MotionEvent event) {
        switch ((Mode)((Object)this.mode.getValue())) {
            case WATCHDOG: {
                if (!this.isInsideBlock()) break;
                if (this.mc.gameSettings.keyBindJump.isKeyDown()) {
                    event.setY(this.mc.thePlayer.motionY += (double)0.088f);
                } else if (this.mc.gameSettings.keyBindSneak.isKeyDown()) {
                    event.setY(this.mc.thePlayer.motionY -= 0.0);
                } else {
                    this.mc.thePlayer.motionY = 0.0;
                    event.setY(0.0);
                }
                MoveUtil.setMoveSpeed(event, 0.3);
                break;
            }
            case WATCHDOGNEW: {
                if (!this.isInsideBlock()) break;
                if (this.mc.gameSettings.keyBindJump.isKeyDown()) {
                    event.setY(this.mc.thePlayer.motionY += (double)0.09f);
                } else if (this.mc.gameSettings.keyBindSneak.isKeyDown()) {
                    event.setY(this.mc.thePlayer.motionY -= 0.0);
                } else {
                    this.mc.thePlayer.motionY = 0.0;
                    event.setY(0.0);
                }
                MoveUtil.setMoveSpeed(event, 0.26);
                break;
            }
            case ARIS: {
                if (this.isInsideBlock() && this.mc.thePlayer.isSneaking()) {
                    float yaw = this.mc.thePlayer.rotationYaw;
                    phasing = true;
                    this.mc.thePlayer.getEntityBoundingBox().offsetAndUpdate((Double)this.distance.getValue() * -Math.sin(Math.toRadians(yaw)), 0.0, (Double)this.distance.getValue() * Math.cos(Math.toRadians(yaw)));
                    break;
                }
                phasing = false;
                break;
            }
            case VANILLA: {
                if (!this.isInsideBlock()) break;
                if (this.mc.gameSettings.keyBindJump.isKeyDown()) {
                    this.mc.thePlayer.motionY = (Double)this.verticalSpeed.getValue();
                    event.setY(this.mc.thePlayer.motionY);
                } else if (this.mc.gameSettings.keyBindSneak.isKeyDown()) {
                    this.mc.thePlayer.motionY = -((Double)this.verticalSpeed.getValue()).doubleValue();
                    event.setY(this.mc.thePlayer.motionY);
                } else {
                    this.mc.thePlayer.motionY = 0.0;
                    event.setY(0.0);
                }
                MoveUtil.setMoveSpeed(event, (Double)this.vanillaSpeed.getValue());
            }
        }
    }

    @Handler(value=PushEvent.class)
    public void onPush(PushEvent event) {
        event.setCancelled(true);
    }

    @Handler(value=InsideBlockRenderEvent.class)
    public void onInside(InsideBlockRenderEvent event) {
        event.setCancelled(true);
    }

    @Handler(value=UpdateEvent.class)
    public void onUpdate(UpdateEvent event) {
        switch ((Mode)((Object)this.mode.getValue())) {
            case WATCHDOGNEW: {
                if (!event.isPre()) {
                    double multiplier = 0.2;
                    double mx = -Math.sin(Math.toRadians(this.mc.thePlayer.rotationYaw));
                    double mz = Math.cos(Math.toRadians(this.mc.thePlayer.rotationYaw));
                    double x = (double)MovementInput.moveForward * multiplier * mx + (double)MovementInput.moveStrafe * multiplier * mz;
                    double z = (double)MovementInput.moveForward * multiplier * mz - (double)MovementInput.moveStrafe * multiplier * mx;
                    Vector2f vector = new Vector2f((float)(-Math.sin(Math.toRadians(this.mc.thePlayer.rotationYaw)) * 0.5), (float)Math.cos(Math.toRadians(this.mc.thePlayer.rotationYaw)) * 0.5f);
                    if (!this.mc.thePlayer.isCollidedHorizontally || this.mc.thePlayer.isOnLadder()) break;
                    this.mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX + x, this.mc.thePlayer.posY, this.mc.thePlayer.posZ + z, false));
                    for (int i = 1; i < 10; ++i) {
                        this.mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX, 8.9, this.mc.thePlayer.posZ, false));
                    }
                    this.mc.thePlayer.setPosition(this.mc.thePlayer.posX + x, this.mc.thePlayer.posY, this.mc.thePlayer.posZ + z);
                    break;
                }
                event.setPitch(90.0f);
                break;
            }
            case WATCHDOG: {
                if (!event.isPre()) {
                    double multiplier = 0.2;
                    double mx = -Math.sin(Math.toRadians(this.mc.thePlayer.rotationYaw));
                    double mz = Math.cos(Math.toRadians(this.mc.thePlayer.rotationYaw));
                    double x = (double)MovementInput.moveForward * multiplier * mx + (double)MovementInput.moveStrafe * multiplier * mz;
                    double z = (double)MovementInput.moveForward * multiplier * mz - (double)MovementInput.moveStrafe * multiplier * mx;
                    Vector2f vector = new Vector2f((float)(-Math.sin(Math.toRadians(this.mc.thePlayer.rotationYaw)) * 0.5), (float)Math.cos(Math.toRadians(this.mc.thePlayer.rotationYaw)) * 0.5f);
                    if (!this.mc.thePlayer.isCollidedHorizontally || this.mc.thePlayer.isOnLadder()) break;
                    this.mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX + x, this.mc.thePlayer.posY, this.mc.thePlayer.posZ + z, false));
                    for (int i = 0; i < 10; ++i) {
                        this.mc.thePlayer.sendQueue.addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX, 1 + i, this.mc.thePlayer.posZ, false));
                    }
                    this.mc.thePlayer.setPosition(this.mc.thePlayer.posX + x, this.mc.thePlayer.posY, this.mc.thePlayer.posZ + z);
                    break;
                }
                event.setPitch(90.0f);
                break;
            }
            case VANILLA: {
                if (!this.mc.gameSettings.keyBindSneak.isPressed() || this.isInsideBlock()) break;
                this.mc.thePlayer.sendQueue.getNetworkManager().sendPacket(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX, this.mc.thePlayer.posY - 2.0, this.mc.thePlayer.posZ, true));
                this.moveUnder = 2;
                break;
            }
            case NCP: {
                String lowerCase = this.mc.getRenderViewEntity().getHorizontalFacing().name().toLowerCase();
                if (!this.mc.thePlayer.isCollidedHorizontally || this.mc.thePlayer.moveForward == 0.0f) break;
                ++this.delay;
                switch (lowerCase) {
                    case "east": {
                        this.mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX + (double)1.0E-5f, this.mc.thePlayer.posY, this.mc.thePlayer.posZ, false));
                        break;
                    }
                    case "west": {
                        this.mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX - (double)1.0E-5f, this.mc.thePlayer.posY, this.mc.thePlayer.posZ, false));
                        break;
                    }
                    case "north": {
                        this.mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX, this.mc.thePlayer.posY, this.mc.thePlayer.posZ - (double)1.0E-5f, false));
                        break;
                    }
                    case "south": {
                        this.mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX, this.mc.thePlayer.posY, this.mc.thePlayer.posZ + (double)1.0E-5f, false));
                        break;
                    }
                }
                if (this.delay < 1) break;
                switch (lowerCase) {
                    case "east": {
                        this.mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX + 2.0, this.mc.thePlayer.posY, this.mc.thePlayer.posZ, false));
                        break;
                    }
                    case "west": {
                        this.mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX - 2.0, this.mc.thePlayer.posY, this.mc.thePlayer.posZ, false));
                        break;
                    }
                    case "north": {
                        this.mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX, this.mc.thePlayer.posY, this.mc.thePlayer.posZ - 2.0, false));
                        break;
                    }
                    case "south": {
                        this.mc.getNetHandler().addToSendQueue(new C03PacketPlayer.C04PacketPlayerPosition(this.mc.thePlayer.posX, this.mc.thePlayer.posY, this.mc.thePlayer.posZ + 2.0, false));
                        break;
                    }
                }
                this.delay = 0;
            }
        }
    }

    private boolean isInBlock(Entity e, float offset) {
        for (int x = MathHelper.floor_double(e.getEntityBoundingBox().minX); x < MathHelper.floor_double(e.getEntityBoundingBox().maxX) + 1; ++x) {
            for (int y = MathHelper.floor_double(e.getEntityBoundingBox().minY); y < MathHelper.floor_double(e.getEntityBoundingBox().maxY) + 1; ++y) {
                for (int z = MathHelper.floor_double(e.getEntityBoundingBox().minZ); z < MathHelper.floor_double(e.getEntityBoundingBox().maxZ) + 1; ++z) {
                    AxisAlignedBB boundingBox;
                    Block block = this.mc.theWorld.getBlockState(new BlockPos((double)x, (float)y + offset, (double)z)).getBlock();
                    if (block == null || block instanceof BlockAir || block instanceof BlockLiquid || (boundingBox = block.getCollisionBoundingBox(this.mc.theWorld, new BlockPos((double)x, (float)y + offset, (double)z), this.mc.theWorld.getBlockState(new BlockPos((double)x, (float)y + offset, (double)z)))) == null || !e.getEntityBoundingBox().intersectsWith(boundingBox)) continue;
                    return true;
                }
            }
        }
        return false;
    }

    private boolean isInsideBlock() {
        for (int x = MathHelper.floor_double(this.mc.thePlayer.getEntityBoundingBox().minX); x < MathHelper.floor_double(this.mc.thePlayer.getEntityBoundingBox().maxX) + 1; ++x) {
            for (int y = MathHelper.floor_double(this.mc.thePlayer.getEntityBoundingBox().minY); y < MathHelper.floor_double(this.mc.thePlayer.getEntityBoundingBox().maxY) + 1; ++y) {
                for (int z = MathHelper.floor_double(this.mc.thePlayer.getEntityBoundingBox().minZ); z < MathHelper.floor_double(this.mc.thePlayer.getEntityBoundingBox().maxZ) + 1; ++z) {
                    Block block = this.mc.theWorld.getBlockState(new BlockPos(x, y, z)).getBlock();
                    if (block == null || block instanceof BlockAir) continue;
                    AxisAlignedBB boundingBox = block.getCollisionBoundingBox(this.mc.theWorld, new BlockPos(x, y, z), this.mc.theWorld.getBlockState(new BlockPos(x, y, z)));
                    if (block instanceof BlockHopper) {
                        boundingBox = new AxisAlignedBB(x, y, z, x + 1, y + 1, z + 1);
                    }
                    if (boundingBox == null || !this.mc.thePlayer.getEntityBoundingBox().intersectsWith(boundingBox)) continue;
                    return true;
                }
            }
        }
        return false;
    }

    @Override
    public void onEnable() {
        phasing = false;
    }

    @Override
    public void onDisable() {
        this.mc.timer.timerSpeed = 1.0f;
        this.delay = 0;
        this.timer.reset();
    }

    public static enum Mode {
        WATCHDOG("Watchdog"),
        WATCHDOGNEW("WatchdogNew"),
        ARIS("Aris"),
        VANILLA("Vanilla"),
        NCP("NCP");

        private final String name;

        private Mode(String name) {
            this.name = name;
        }

        public String getName() {
            return this.name;
        }
    }
}

